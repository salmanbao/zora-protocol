{"language":"Solidity","sources":{"src/helper/SecondarySwap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {ISecondarySwap} from \"../interfaces/ISecondarySwap.sol\";\nimport {IERC20Z} from \"../interfaces/IERC20Z.sol\";\nimport {ISwapRouter} from \"../interfaces/uniswap/ISwapRouter.sol\";\nimport {IZoraTimedSaleStrategy} from \"../interfaces/IZoraTimedSaleStrategy.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\n\ncontract SecondarySwap is ISecondarySwap, ReentrancyGuard, IERC1155Receiver {\n    uint256 internal constant ONE_ERC_20 = 1e18;\n\n    bytes4 constant ON_ERC1155_RECEIVED_HASH = IERC1155Receiver.onERC1155Received.selector;\n\n    IWETH public WETH;\n    ISwapRouter public swapRouter;\n    uint24 public uniswapFee;\n    IZoraTimedSaleStrategy public zoraTimedSaleStrategy;\n\n    /// @notice This must be called in the same transaction that the contract is created on.\n    function initialize(IWETH weth_, ISwapRouter swapRouter_, uint24 uniswapFee_, IZoraTimedSaleStrategy zoraTimedSaleStrategy_) external {\n        // Ensure a non-zero WETH address is passed upon initialization\n        if (address(weth_) == address(0)) {\n            revert AddressZero();\n        }\n\n        // Ensure this contract cannot be reinitialized\n        if (address(WETH) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        WETH = weth_;\n        swapRouter = swapRouter_;\n        uniswapFee = uniswapFee_;\n        zoraTimedSaleStrategy = zoraTimedSaleStrategy_;\n    }\n\n    /// @notice ETH -> WETH -> ERC20Z -> ERC1155\n    function buy1155(\n        address erc20zAddress,\n        uint256 num1155ToBuy,\n        address payable recipient,\n        address payable excessRefundRecipient,\n        uint256 maxEthToSpend,\n        uint160 sqrtPriceLimitX96\n    ) external payable nonReentrant {\n        // Ensure the recipient address is valid\n        if (recipient == address(0)) {\n            revert InvalidRecipient();\n        }\n\n        // Get the amount of ETH sent\n        uint256 amountETHIn = msg.value;\n\n        // Ensure ETH is sent with the transaction\n        if (amountETHIn == 0) {\n            revert NoETHSent();\n        }\n\n        // Convert ETH to WETH\n        WETH.deposit{value: amountETHIn}();\n\n        // Approve the swap router to spend WETH\n        WETH.approve(address(swapRouter), amountETHIn);\n\n        // Calculate the expected amount of ERC20Z\n        uint256 expectedAmountERC20Out = num1155ToBuy * ONE_ERC_20;\n\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({\n            tokenIn: address(WETH),\n            tokenOut: erc20zAddress,\n            fee: uniswapFee,\n            recipient: address(this),\n            amountOut: expectedAmountERC20Out,\n            amountInMaximum: maxEthToSpend,\n            sqrtPriceLimitX96: sqrtPriceLimitX96\n        });\n\n        // Execute the swap and get the amount of WETH used\n        uint256 amountWethUsed = swapRouter.exactOutputSingle(params);\n\n        // Ensure that the expected amount of ERC20Z was received\n        if (IERC20Z(erc20zAddress).balanceOf(address(this)) < expectedAmountERC20Out) {\n            revert ERC20ZMinimumAmountNotReceived();\n        }\n\n        // Approve the ERC20Z tokens to be converted to ERC1155s\n        IERC20Z(erc20zAddress).approve(erc20zAddress, expectedAmountERC20Out);\n\n        // Convert ERC20Z to ERC1155\n        IERC20Z(erc20zAddress).unwrap(expectedAmountERC20Out, recipient);\n\n        // If there is any excess WETH:\n        if (amountWethUsed < amountETHIn) {\n            // Convert the excess WETH to ETH\n            WETH.withdraw(amountETHIn - amountWethUsed);\n\n            // Refund the excess ETH to the recipient\n            Address.sendValue(excessRefundRecipient, msg.value - amountWethUsed);\n        }\n\n        emit SecondaryBuy(msg.sender, recipient, erc20zAddress, amountWethUsed, num1155ToBuy);\n    }\n\n    /// @notice ERC1155 -> ERC20Z -> WETH -> ETH\n    function sell1155(\n        address erc20zAddress,\n        uint256 num1155ToSell,\n        address payable recipient,\n        uint256 minEthToAcquire,\n        uint160 sqrtPriceLimitX96\n    ) external nonReentrant {\n        IERC20Z.TokenInfo memory tokenInfo = IERC20Z(erc20zAddress).tokenInfo();\n\n        // Transfer ERC1155 tokens from sender to this contract and wrap them\n        IERC1155(tokenInfo.collection).safeTransferFrom(msg.sender, erc20zAddress, tokenInfo.tokenId, num1155ToSell, abi.encode(address(this)));\n\n        _sell1155(erc20zAddress, num1155ToSell, recipient, minEthToAcquire, sqrtPriceLimitX96);\n    }\n\n    /// @notice ERC1155 -> ERC20Z -> WETH -> ETH\n    function _sell1155(address erc20zAddress, uint256 num1155ToSell, address payable recipient, uint256 minEthToAcquire, uint160 sqrtPriceLimitX96) private {\n        // Ensure the recipient is valid\n        if (recipient == address(0)) {\n            revert InvalidRecipient();\n        }\n\n        // Calculate expected amount of ERC20Z\n        uint256 expectedAmountERC20In = num1155ToSell * 1e18;\n\n        // Ensure that the conversion was successful\n        if (IERC20Z(erc20zAddress).balanceOf(address(this)) < expectedAmountERC20In) {\n            revert ERC20ZEquivalentAmountNotConverted();\n        }\n\n        // Approve swap router to spend ERC20Z tokens\n        IERC20Z(erc20zAddress).approve(address(swapRouter), expectedAmountERC20In);\n\n        // Set up parameters for the swap from ERC20Z to WETH\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: erc20zAddress,\n            tokenOut: address(WETH),\n            fee: uniswapFee,\n            recipient: address(this),\n            amountIn: expectedAmountERC20In,\n            amountOutMinimum: minEthToAcquire,\n            sqrtPriceLimitX96: sqrtPriceLimitX96\n        });\n\n        // Execute the swap and receive WETH\n        uint256 amountWethOut = swapRouter.exactInputSingle(params);\n\n        // Convert WETH to ETH\n        WETH.withdraw(amountWethOut);\n\n        // Transfer ETH to the recipient\n        Address.sendValue(recipient, amountWethOut);\n\n        emit SecondarySell(msg.sender, recipient, erc20zAddress, amountWethOut, num1155ToSell);\n    }\n\n    /// @notice Receive transfer hook that allows to sell 1155s for eth based on the secondary market value\n    function onERC1155Received(address, address, uint256 id, uint256 value, bytes calldata data) external override nonReentrant returns (bytes4) {\n        address collection = msg.sender;\n\n        uint256 num1155ToSell = value;\n\n        (address payable recipient, uint256 minEthToAcquire, uint160 sqrtPriceLimitX96) = abi.decode(data, (address, uint256, uint160));\n\n        address erc20zAddress = zoraTimedSaleStrategy.sale(collection, id).erc20zAddress;\n\n        if (erc20zAddress == address(0)) {\n            revert SaleNotSet();\n        }\n\n        // assume this contract has 1155s, transfer them to the erc20z and wrap them\n        IERC1155(collection).safeTransferFrom(address(this), erc20zAddress, id, num1155ToSell, abi.encode(address(this)));\n\n        _sell1155(erc20zAddress, num1155ToSell, recipient, minEthToAcquire, sqrtPriceLimitX96);\n\n        return ON_ERC1155_RECEIVED_HASH;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external pure override returns (bytes4) {\n        revert NotSupported();\n    }\n\n    receive() external payable {\n        if (msg.sender != address(WETH)) {\n            revert OnlyWETH();\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"},"src/interfaces/ISecondarySwap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/*\n\n\n             ░░░░░░░░░░░░░░              \n        ░░▒▒░░░░░░░░░░░░░░░░░░░░        \n      ░░▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░      \n    ░░▒▒▒▒░░░░░░░░░░░░░░    ░░░░░░░░    \n   ░▓▓▒▒▒▒░░░░░░░░░░░░        ░░░░░░░    \n  ░▓▓▓▒▒▒▒░░░░░░░░░░░░        ░░░░░░░░  \n  ░▓▓▓▒▒▒▒░░░░░░░░░░░░░░    ░░░░░░░░░░  \n  ░▓▓▓▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░  \n  ░▓▓▓▓▓▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░  \n   ░▓▓▓▓▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░  \n    ░░▓▓▓▓▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░    \n    ░░▓▓▓▓▓▓▒▒▒▒▒▒▒▒░░░░░░░░░▒▒▒▒▒░░    \n      ░░▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░      \n          ░░▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░          \n\n               OURS TRULY,\n\n\n*/\n\ninterface ISecondarySwap {\n    enum SecondaryType {\n        /// @notice Buy 1155 tokens event\n        BUY,\n        /// @notice Sell 1155 tokens event\n        SELL\n    }\n\n    /// @notice SecondaryBuy Event\n    /// @param msgSender The sender of the message\n    /// @param recipient The recipient of the 1155 tokens bought\n    /// @param erc20zAddress The ERC20Z address\n    /// @param amountETHSold The amount of ETH sold\n    /// @param num1155Purchased The number of 1155 tokens purchased\n    event SecondaryBuy(address indexed msgSender, address indexed recipient, address indexed erc20zAddress, uint256 amountETHSold, uint256 num1155Purchased);\n\n    /// @notice SecondarySell Event\n    /// @param msgSender The sender of the message\n    /// @param recipient The recipient of the ETH purchased\n    /// @param erc20zAddress The ERC20Z address\n    /// @param amountETHPurchased The amount of ETH purchased\n    /// @param num1155Sold The number of 1155 tokens sold\n    event SecondarySell(address indexed msgSender, address indexed recipient, address indexed erc20zAddress, uint256 amountETHPurchased, uint256 num1155Sold);\n\n    /// @notice SecondaryComment Event\n    /// @param sender The sender of the comment\n    /// @param collection The collection address\n    /// @param tokenId The token ID\n    /// @param quantity The quantity of tokens minted\n    /// @param quantity The quantity of tokens minted\n    /// @param comment The comment\n    /// @param secondaryType The secondary event type\n    event SecondaryComment(\n        address indexed sender,\n        address indexed collection,\n        uint256 indexed tokenId,\n        uint256 quantity,\n        string comment,\n        SecondaryType secondaryType\n    );\n\n    /// @notice Invalid recipient\n    error InvalidRecipient();\n\n    /// @notice No ETH sent\n    error NoETHSent();\n\n    /// @notice ERC20Z minimum amount not received\n    error ERC20ZMinimumAmountNotReceived();\n\n    /// @notice ERC20Z equivalent amount not converted\n    error ERC20ZEquivalentAmountNotConverted();\n\n    /// @notice Only WETH can be received\n    error OnlyWETH();\n\n    /// @notice Operation not supported\n    error NotSupported();\n\n    /// @notice Timed Sale has not been configured for the collection and token ID\n    error SaleNotSet();\n\n    /// @notice Reverts if an address param is passed as zero address\n    error AddressZero();\n\n    /// @notice Reverts if the contract is already initialized\n    error AlreadyInitialized();\n}\n"},"src/interfaces/IERC20Z.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IERC20Z is IERC20Metadata {\n    /// @notice TokenInfo struct returned by the information function\n    struct TokenInfo {\n        /// @notice The collection address\n        address collection;\n        /// @notice The token ID\n        uint256 tokenId;\n        /// @notice The creator address\n        address creator;\n    }\n\n    /// @notice Event for when the ERC1155s are directly converted to ERC20Zs\n    /// @param erc20z ERC20Z Address\n    /// @param amount20z ERC20Z Amount\n    /// @param collection Collection address\n    /// @param tokenId ID for the ERC1155 token swapped\n    /// @param amount1155 Amount of 1155 converted\n    /// @param recipient Recipient of the conversion\n    event ConvertedTo20z(address indexed erc20z, uint256 amount20z, address collection, uint256 tokenId, uint256 amount1155, address recipient);\n\n    /// @notice Event for when ERC20Zs are directly converted to ERC1155\n    /// @param erc20z ERC20Z Address\n    /// @param amount20z ERC20Z Amount\n    /// @param collection Collection address\n    /// @param tokenId ID for the ERC1155 token swapped\n    /// @param amount1155 Amount of 1155 converted\n    /// @param recipient Recipient of the conversion\n    event ConvertedTo1155(address indexed erc20z, uint256 amount20z, address collection, uint256 tokenId, uint256 amount1155, address recipient);\n\n    /// @notice Event for when the secondary market is activated\n    /// @param token0 Token 0 for uniswap liquidity\n    /// @param amount0 Amount 0 for uniswap liquidity\n    /// @param token1 Token 1 for uniswap liquidity\n    /// @param amount1 Amount 1 for uniswap liquidity\n    /// @param fee Uniswap fee amount\n    /// @param positionId ERC721 Position ID for the default liquidity\n    /// @param lpLiquidity amount of lp liquidity held by this contract\n    /// @param erc20Excess ERC20 excess amount burned\n    /// @param erc1155Excess ERC1155 excess amount burned\n    event SecondaryMarketActivated(\n        address indexed token0,\n        uint256 indexed amount0,\n        address token1,\n        uint256 amount1,\n        uint256 fee,\n        uint256 positionId,\n        uint256 lpLiquidity,\n        uint256 erc20Excess,\n        uint256 erc1155Excess\n    );\n\n    /// @notice Event for when admin mint NFTs are received\n    /// @param quantity the amount received\n    event ReceivedAdminMintNFTs(uint256 quantity);\n\n    /// @notice Errors when attempts to reactivate\n    error AlreadyActivatedCannotReactivate();\n\n    /// @notice ERC1155 Ids do not match values length\n    error IDsDoNotMatchValuesLength();\n\n    /// @notice Passing in wrong ERC1155 token id to swap\n    error TokenIdNotValidToSwap();\n\n    /// @notice Action sent with ERC1155 data call is not known\n    error UnknownReceiveActionDataCall();\n\n    /// @notice Only supports receiving ERC721 Pool NFTs\n    error OnlySupportReceivingERC721UniswapPoolNFTs();\n\n    /// @notice Error when trying to swap ERC1155 to ERC20Z without the market being started.\n    error SecondaryMarketHasNotYetStarted();\n\n    /// @notice Only supports recieving ERC1155 associated with ERC20Z NFTs.\n    error OnlySupportReceivingERC1155AssociatedZoraNFT();\n\n    /// @notice Unauthorized to call this function\n    error OnlySaleStrategy();\n\n    /// @notice Pool creation failed\n    error PoolCreationFailed();\n\n    /// @notice Params are invalid\n    error InvalidParams();\n\n    /// @notice Insufficient balance\n    error InsufficientBalance();\n\n    /// @notice Invalid amount of ERC20z tokens\n    error InvalidAmount20z();\n\n    /// @notice Invalid ERC20z transfer\n    error Invalid20zTransfer();\n\n    /// @notice Recipient address cannot be zero\n    error RecipientAddressZero();\n\n    /// @notice Token URI\n    function tokenURI() external view returns (string memory);\n\n    /// @notice Token information\n    function tokenInfo() external view returns (TokenInfo memory);\n\n    /// @notice Returns the ERC20Z contract URI\n    function contractURI() external view returns (string memory);\n\n    /// @notice Token liquidity information getter\n    function tokenLiquidityInfo() external view returns (address pool, uint256 initialLiquidityPositionId);\n\n    /// @notice Initialize the ERC20Z token\n    /// @param collection The collection address\n    /// @param tokenId The token ID\n    /// @param name The token name\n    /// @param symbol The token symbol\n    function initialize(address collection, uint256 tokenId, string memory name, string memory symbol) external returns (address);\n\n    /// @notice Activate the ERC20Z token\n    /// @param erc20TotalSupply The total supply of the ERC20 token\n    /// @param erc20Reserve The reserve of the ERC20 token\n    /// @param erc20Liquidity The liquidity of the ERC20 token\n    /// @param erc20Excess The excess of the ERC20 token\n    /// @param erc1155Excess The excess of the ERC1155 token\n    function activate(uint256 erc20TotalSupply, uint256 erc20Reserve, uint256 erc20Liquidity, uint256 erc20Excess, uint256 erc1155Excess) external;\n\n    /// @notice Convert 1155 to ERC20z tokens\n    /// @param amount1155 The amount of 1155 tokens to convert\n    /// @param recipient The recipient address\n    function wrap(uint256 amount1155, address recipient) external;\n\n    /// @notice Convert ERC20z to 1155 tokens\n    /// @param amount20z The amount of ERC20z tokens to convert\n    /// @param recipient The recipient address\n    function unwrap(uint256 amount20z, address recipient) external;\n}\n"},"src/interfaces/uniswap/ISwapRouter.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IUniswapV3SwapCallback} from \"./IUniswapV3SwapCallback.sol\";\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n}\n"},"src/interfaces/IZoraTimedSaleStrategy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IZoraTimedSaleStrategy {\n    struct SalesConfig {\n        /// @notice Unix timestamp for the sale start\n        uint64 saleStart;\n        /// @notice Unix timestamp for the sale end\n        uint64 saleEnd;\n        /// @notice The ERC20Z name\n        string name;\n        /// @notice The ERC20Z symbol\n        string symbol;\n    }\n\n    /// @dev This is used to pass in parameters for the `updateSale` function\n    struct SalesConfigV2 {\n        /// @notice Unix timestamp for the sale start\n        uint64 saleStart;\n        /// @notice The amount of time after the `minimumMarketEth` is reached until the secondary market can be launched\n        uint64 marketCountdown;\n        /// @notice The amount of ETH required to launch a market\n        uint256 minimumMarketEth;\n        /// @notice The ERC20Z name\n        string name;\n        /// @notice The ERC20Z symbol\n        string symbol;\n    }\n\n    /// @dev This is the SaleV1 style sale with a set end and start time and is used in both cases for storing key sale information\n    struct SaleStorage {\n        /// @notice The ERC20z address\n        address payable erc20zAddress;\n        /// @notice The sale start time\n        uint64 saleStart;\n        /// @notice The Uniswap pool address\n        address poolAddress;\n        /// @notice The sale end time\n        uint64 saleEnd;\n        /// @notice Boolean if the secondary market has been launched\n        bool secondaryActivated;\n    }\n\n    /// @dev These are additional fields required for the SaleV2 style functionality. SaleV2 sets SaleV1 parameters as well.\n    /// @notice SaleV2 is now the default strategy but old strategies without V2 config will operate as previously.\n    struct SaleStorageV2 {\n        /// @notice The amount of ETH required to launch a market\n        uint256 minimumMarketEth;\n        /// @notice The amount of time after the `minimumMarketEth` is reached until the secondary market can be launched.\n        uint64 marketCountdown;\n    }\n\n    /// @dev Sales data virutal struct used for emitting events having SaleV1 and SaleV2 structs\n    struct SaleData {\n        /// @notice Unix timestamp for the sale start\n        uint64 saleStart;\n        /// @notice The amount of time after the `minimumMarketEth` is reached until the secondary market can be launched\n        uint64 marketCountdown;\n        /// @notice Unix timestamp for the sale end -- this will default to 0 until the market countdown is kicked off\n        uint64 saleEnd;\n        /// @notice Boolean if the secondary market has been launched\n        bool secondaryActivated;\n        /// @notice The amount of ETH required to launch a market\n        uint256 minimumMarketEth;\n        /// @notice The Uniswap pool address\n        address poolAddress;\n        /// @notice The ERC20z address\n        address payable erc20zAddress;\n        /// @notice The ERC20Z name\n        string name;\n        /// @notice The ERC20Z symbol\n        string symbol;\n    }\n\n    /// @notice Activated ERC20 information used for the structs\n    struct ERC20zActivate {\n        /// @notice Total Supply of ERC20z tokens\n        uint256 finalTotalERC20ZSupply;\n        /// @notice ERC20z Reserve price\n        uint256 erc20Reserve;\n        /// @notice ERC20z Liquidity\n        uint256 erc20Liquidity;\n        /// @notice Excess amount of ERC20z\n        uint256 excessERC20;\n        /// @notice Excess amount of 1155\n        uint256 excessERC1155;\n        /// @notice Additional ERC1155 to mint\n        uint256 additionalERC1155ToMint;\n        /// @notice Final 1155 Supply\n        uint256 final1155Supply;\n    }\n\n    /// @notice V1 storage structs for the timed sale\n    struct ZoraTimedSaleStrategyStorage {\n        /// @notice The Zora reward recipient\n        address zoraRewardRecipient;\n        /// @notice The sales mapping\n        mapping(address collection => mapping(uint256 tokenId => SaleStorage)) sales;\n    }\n\n    /// @notice V2 storage structs for the timed sale\n    struct ZoraTimedSaleStrategyStorageV2 {\n        /// @notice The sales mapping\n        mapping(address collection => mapping(uint256 tokenId => SaleStorageV2)) salesV2;\n    }\n\n    struct RewardsSettings {\n        /// @notice The sum of all individual rewards\n        uint256 totalReward;\n        /// @notice Creator reward\n        uint256 creatorReward;\n        /// @notice Creator referral reward\n        uint256 createReferralReward;\n        /// @notice Mint referral reward\n        uint256 mintReferralReward;\n        /// @notice Market reward\n        uint256 marketReward;\n        /// @notice Zora reward\n        uint256 zoraReward;\n    }\n\n    /// @notice SaleSet Event\n    /// @param collection The collection address\n    /// @param tokenId The token ID\n    /// @param salesConfig The sales configuration\n    /// @param erc20zAddress The ERC20Z address\n    /// @param poolAddress The Uniswap pool address\n    /// @param mintFee The total fee in eth to mint each token\n    event SaleSet(address indexed collection, uint256 indexed tokenId, SalesConfig salesConfig, address erc20zAddress, address poolAddress, uint256 mintFee);\n\n    /// @notice Emitted when a sale is created and updated, and when a market countdown is underway\n    /// @param collection The collection address\n    /// @param tokenId The token ID\n    /// @param saleData The sale data\n    /// @param mintFee The total fee in eth to mint each token\n    event SaleSetV2(address indexed collection, uint256 indexed tokenId, SaleData saleData, uint256 mintFee);\n\n    /// @notice MintComment Event\n    /// @param sender The sender of the comment\n    /// @param collection The collection address\n    /// @param tokenId The token ID\n    /// @param quantity The quantity of tokens minted\n    /// @param comment The comment\n    event MintComment(address indexed sender, address indexed collection, uint256 indexed tokenId, uint256 quantity, string comment);\n\n    /// @notice Emitted when rewards are distributed from this sale strategy\n    /// @param creator The creator of the token\n    /// @param creatorReward The creator reward\n    /// @param createReferral The create referral\n    /// @param createReferralReward The create referral reward\n    /// @param mintReferral The mint referral\n    /// @param mintReferralReward The mint referral reward\n    /// @param market The Uniswap market\n    /// @param marketReward The Uniswap market reward\n    /// @param zoraRecipient The Zora recipient\n    /// @param zoraReward The Zora reward\n    event ZoraTimedSaleStrategyRewards(\n        address indexed collection,\n        uint256 indexed tokenId,\n        address creator,\n        uint256 creatorReward,\n        address createReferral,\n        uint256 createReferralReward,\n        address mintReferral,\n        uint256 mintReferralReward,\n        address market,\n        uint256 marketReward,\n        address zoraRecipient,\n        uint256 zoraReward\n    );\n\n    /// @notice MarketLaunched Event\n    /// @param collection The collection address\n    /// @param tokenId The token ID\n    /// @param erc20zAddress The ERC20Z address\n    /// @param poolAddress The Uniswap pool address\n    event MarketLaunched(address indexed collection, uint256 indexed tokenId, address erc20zAddress, address poolAddress);\n\n    /// @notice ZoraRewardRecipientUpdated Event\n    /// @param prevRecipient The previous Zora reward recipient\n    /// @param newRecipient The new Zora reward recipient\n    event ZoraRewardRecipientUpdated(address indexed prevRecipient, address indexed newRecipient);\n\n    /// @notice Error thrown when market is attempted to be started with no sales completed\n    error NeedsToBeAtLeastOneSaleToStartMarket();\n\n    /// @notice Error thrown when market minimum is not reached\n    error MarketMinimumNotReached();\n\n    /// @notice requestMint() is not used in minter, use mint() instead\n    error RequestMintInvalidUseMint();\n\n    /// @notice Cannot set address to zero\n    error AddressZero();\n\n    /// @notice The wrong value was sent\n    error WrongValueSent();\n\n    /// @notice The sale has already been set\n    error SaleAlreadySet();\n\n    /// @notice The sale has not started\n    error SaleHasNotStarted();\n\n    /// @notice The sale has already started\n    error SaleV2AlreadyStarted();\n\n    /// @notice The sale is in progress\n    error SaleInProgress();\n\n    /// @notice The sale has ended\n    error SaleEnded();\n\n    /// @notice The v2 sale has ended\n    error SaleV2Ended();\n\n    /// @notice The sale has not been set\n    error SaleNotSet();\n\n    /// @notice The  has not been set\n    error SaleV2NotSet();\n\n    /// @notice Insufficient funds\n    error InsufficientFunds();\n\n    /// @notice Only the Zora reward recipient\n    error OnlyZoraRewardRecipient();\n\n    /// @notice ResetSale is not available in this sale strategy\n    error ResetSaleNotAvailable();\n\n    /// @notice Zora Creator 1155 Contract needs to support IReduceSupply\n    error ZoraCreator1155ContractNeedsToSupportReduceSupply();\n\n    /// @notice The sale start time cannot be after the sale ends\n    error StartTimeCannotBeAfterEndTime();\n\n    /// @notice The sale start time cannot be in the past\n    error EndTimeCannotBeInThePast();\n\n    /// @notice The market has already been launched\n    error MarketAlreadyLaunched();\n\n    /// @notice The minimum amount of ETH required to set a sale\n    error MinimumMarketEthNotMet();\n\n    /// @notice This is deprecated and used for short-term backwards compatibility, use `setSaleV2()` instead.\n    ///         This creates a V2 sale under the hood and ignores the passed `saleEnd` field.\n    ///         Defaults for the V2 sale: `marketCountdown` = 24 hours & `minimumMarketEth` = 0.00222 ETH (200 mints).\n    /// @param tokenId The collection token id to set the sale config for\n    /// @param salesConfig The sale config to set\n    function setSale(uint256 tokenId, SalesConfig calldata salesConfig) external;\n\n    /// @notice Called by an 1155 collection to set the sale config for a given token\n    /// @dev Additionally creates an ERC20Z and Uniswap V3 pool for the token\n    /// @param tokenId The collection token id to set the sale config for\n    /// @param salesConfig The sale config to set\n    function setSaleV2(uint256 tokenId, SalesConfigV2 calldata salesConfig) external;\n\n    /// @notice Called by a collector to mint a token\n    /// @param mintTo The address to mint the token to\n    /// @param quantity The quantity of tokens to mint\n    /// @param collection The address of the 1155 token to mint\n    /// @param tokenId The ID of the token to mint\n    /// @param mintReferral The address of the mint referral\n    /// @param comment The optional mint comment\n    function mint(address mintTo, uint256 quantity, address collection, uint256 tokenId, address mintReferral, string calldata comment) external payable;\n\n    /// @notice Gets the create referral address for a given token\n    /// @param collection The address of the collection\n    /// @param tokenId The ID of the token\n    function getCreateReferral(address collection, uint256 tokenId) external view returns (address createReferral);\n\n    /// @notice Computes the rewards for a given quantity of tokens\n    /// @param quantity The quantity of tokens to compute rewards for\n    function computeRewards(uint256 quantity) external returns (RewardsSettings memory);\n\n    /// @notice Update the Zora reward recipient\n    function setZoraRewardRecipient(address recipient) external;\n\n    /// @notice Returns the sale config for a given token\n    /// @param collection The collection address\n    /// @param tokenId The ID of the token to get the sale config for\n    function sale(address collection, uint256 tokenId) external view returns (SaleStorage memory);\n\n    /// @notice Returns the sale config for a given token\n    /// @param collection The collection address\n    /// @param tokenId The ID of the token to get the sale config for\n    function saleV2(address collection, uint256 tokenId) external view returns (SaleData memory);\n\n    /// @notice Calculate the ERC20z activation values\n    /// @param collection The collection address\n    /// @param tokenId The token ID\n    /// @param erc20zAddress The ERC20Z address\n    function calculateERC20zActivate(address collection, uint256 tokenId, address erc20zAddress) external view returns (ERC20zActivate memory);\n\n    /// @notice Called by an 1155 collection to update the sale time if the sale has not started or ended.\n    /// @param tokenId The 1155 token id\n    /// @param newStartTime The new start time for the sale, ignored if the existing sale has already started\n    /// @param newMarketCountdown The new market countdown for the sale\n    function updateSale(uint256 tokenId, uint64 newStartTime, uint64 newMarketCountdown) external;\n\n    /// @notice Called by anyone upon the end of a primary sale to launch the secondary market.\n    /// @param collection The 1155 collection address\n    /// @param tokenId The 1155 token id\n    function launchMarket(address collection, uint256 tokenId) external;\n}\n"},"src/interfaces/IWETH.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n\n    function balanceOf(address guy) external view returns (uint256);\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"src/interfaces/uniswap/IUniswapV3SwapCallback.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"}},"settings":{"remappings":["ds-test/=node_modules/ds-test/src/","forge-std/=node_modules/forge-std/src/","@openzeppelin/=node_modules/@openzeppelin/","@zoralabs/protocol-rewards/=node_modules/@zoralabs/protocol-rewards/","@zoralabs/shared-contracts/=node_modules/@zoralabs/shared-contracts/src/","solady/=node_modules/solady/src/"],"optimizer":{"enabled":true,"runs":1000000},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":true,"libraries":{}}}
